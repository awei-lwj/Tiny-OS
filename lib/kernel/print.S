;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 7个步骤
; 1. 备份寄存器现场。
; 2. 获取光标坐标值，光标坐标值是下一个可打印宇符的位置。
; 3. 获取光标坐标值，光标坐标值是下一个可打印宇符的位置。
; 4. 判断字符是否为控制字符，若是回车符、换行符、退格符三种控制字符之 ，则进入相应的处理流程。否则，其余字符都被粗暴地认为是可见字符，进入输出流程处理。
; 5. 判断是否需要滚屏。
; 6. 更新光标坐标值，使其指向下一个打印字符的位置。
; 7. 恢复寄存器现场，退出。
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TI_GDT           equ 0                           ; 定义了视频段的选择子
RPL0             equ 0
SELECTOR_VIDEO   equ (0x0003<<3) + TI_GDT + RPL0  

; 用section定义了1个数据区，里面用伪指令dq申请了8字节的内存put_int_buffer
; ,它作为转换过程中用的缓冲区，实际上它的用途就是用于存储转换后的字符。
section .data                           
put_int_buffer    dq  0                          ; 定义8字节缓冲区用于数字到字符的转换

[bits 32]
section .text
;--------------------------------------------------------------------------------------------------------------
;put_str 通过put_char来打印以0字符结尾的字符串
;--------------------------------------------------------------------------------------------------------------
;输入：栈中参数为打印的字符串
;输出：无

global put_str
put_str:
; 由于本函数中只用到了ebx和ecx,只备份这两个寄存器
    push         ebx
    push         ecx
    xor          ecx,  ecx                       ; 准备用ecx存储参数,清空
    mov          ebx,  [esp + 12]                ; 从栈中得到待打印的字符串地址  
.goon:
    mov           cl,  [ebx]
    cmp           cl,  0                         ; 如果处理到了字符串尾,跳到结束处返回
    jz  .str_cover
    push         ecx                             ; 为put_char函数传递参数
    call put_char                 
    add          esp,  4                         ; 回收参数所占的栈空间
    inc          ebx                             ; 使ebx指向下一个字符
    jmp .goon                                    
.str_cover:
    pop          ecx 
    pop          ebx
    ret
  
;--------------------------------------------------------  put_char  ----------------------------------------------
;功能描述： 把栈中的1个字符写入光标所在处
;------------------------------------------------------------------------------------------------------------------
global put_char                                  ; 是通过关键字global把函数put_char导出为全局符号，这样对外部文件可见了
put_char:        ; 第一步
    pushad       ; 备份32为寄存器环境,8个寄存器，入栈的先后顺序: EAX->ECX->EDX->EBX->ESP->EBP->ESI->EDI
    ; 需要保证gs中为正确的视频段选择子，为了保险起见，每次打印时都为gs赋值
    mov           ax,  SELECTOR_VIDEO            ; 不能直接把立即数送到段寄存器中
    mov           gs,  ax                        ; 14～15为gs安装正确的选择子
                                                 ; 为了防止将来因为GS导致CPU抛异常才提前加的，这 put_char本身的功能是无关的。
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  获取当前光标的位置  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 先获得高8位，第二步
    mov           dx,  0x03d4                    ; 索引寄存器
    mov           al,  0x0e                      ; 用于提供光标位置的高8位
    out           dx,  al
    mov           dx,  0x03d5                    ; 通过读写数据端口0x3d5来获得或设置光标位置
    in            al,  dx                        ; 得到年光标位置的高8位
    mov           ah,  al

    ; 再获取低8位
    mov           dx,  0x03d4
    mov           al,  0x0f
    out           dx,  al
    mov           dx,  0x03d5 
    in            al,  dx                        ; 至此，寄存器ax中是光标完整的16位坐标值

    ; 将光标存入bx
    mov           bx,  ax                        ; 将光标值从ax寄存器复制到bx中
    ; 下面这行是在栈中获取待打印的字符,第三步          ；36行获取压入的ASCII玛
    mov          ecx,  [esp + 36]                ; pushad压入 4 * 8 = 32 字节，加入主调函数4字节的返回地址，故esp + 36字节
    cmp           cl,  0xd                       ; CR是0x0d,LF是0x0a
    jz  .is_carriage_return                      ; 跳过回车符CR(carriage_return)无视
    cmp           cl,  0xa
    jz  .is_line_feed                            ; 同理，换行符LF

    cmp           cl,  0x8                       ; BS(backspace)的asc码是8
    jz  .is_backspace                            ; 空格符
    jmp .put_other 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.is_backspace:                                 ; 用来处理退格键backspace的
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  backspace的一点说明  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 当为backspace时,本质上只要将光标移向前一个显存位置即可.后面再输入的字符自然会覆盖此处的字符
; 但有可能在键入backspace后并不再键入新的字符,这时在光标已经向前移动到待删除的字符位置,但字符还在原处
; 这就显得好怪异,所以此处添加了空格或空字符0
    dec           bx                             ; 用dec指令先将bx，这样光标坐标便指向前一个字符了
    shl           bx,  1                         ; 将bx左移1位，相当于乘以2，用shl指令做乘法比用mul指令方便,由于字符在显存中占2字节，低字节是ASCII码，高字符是属性
    mov byte [gs:bx], 0x20                       ; 将待删除的字节补为0或空格皆可,在bx处，也就是低字节处先把空格的ASCII码但0x20写入
    inc           bx                             ; 再通过inc指令把bx加上 ，这样b 便指向了该字符的属性位置
    mov byte [gs:bx], 0x07                       ; 再将属性Ox7写入到高字节
    shr           bx,  1                         ; 右移指令shr将bx右移1位相当于除2取整，余数不要了，这样bx便由显存中的相对地址恢复成了光标坐标
    jmp .set_cursor                              ; 跳到设置光标的流程.set cursor ，经过它的处理，光标才会显示在新位置。
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 第61~69行处理可见字符的代码
.put_other:
    shl           bx,  1                         ; 光标位置是用2字节表示,将光标值乘2,表示对应显存中的偏移字节
    mov      [gs:bx],  cl                        ; ascii字符本身
    inc           bx
    mov byte [gs:bx],  0x07                      ; 字符属性
    shr           bx,  1                         ; 恢复老的光标值
    inc           bx                             ; 下一个光标值
    cmp           bx,  2000
    jl .set_cursor                               ; 若光标值小于2000,表示未写到显存的最后,则去设置新的光标值
                                                 ; 若超出屏幕字符数大小(2000)则换行处理
.is_line_feed:                                 ; 是换行符LF(\n),处理回车换行符的代码,滚屏操作也需要它
.is_carriage_return:                           ; 是回车符CR(\r)
; 如果是CR(\r),只要把光标移到行首就行了               ; 74~78行是在处理回车符	  
    xor           dx,  dx                        ; dx是被除数的高16位,清0.
    mov           ax,  bx                        ; ax是被除数的低16位.
    mov           si,  80                        ; 由于是效仿linux，linux中\n便表示下一行的行首，所以本系统中，
    div           si                             ; 把\n和\r都处理为linux中\n的意思，也就是下一行的行首。
    sub           bx,  dx                        ; 光标值减去除80的余数便是取整
    ; 以上4行处理\r的代码

.is_carriage_return_end:                       ; 回车符CR处理结束
    add           bx,  80
    cmp           bx,  2000                      ; 回车换行符处理流程中自己的滚屏判断，
.is_line_feed_end:                             ; 若是LF(\n),将光标移+80便可。  
    jl .set_cursor

; 屏幕行范围是0~24,滚屏的原理是将屏幕的1~24行搬运到0~23行,再将第24行用空格填充
  .roll_screen:                                  ; 若超出屏幕大小，开始滚屏
    cld                                          ; mov ecx,960，它用来控制 rep 重复执行指令的次数
    mov          ecx,  960                       ; 一共有2000-80=1920个字符要搬运,共1920*2=3840字节.一次搬4字节,共3840/4=960次 
    mov          esi,  0xc00b80a0                ; 把要复制的起始地址赋给esi寄存器,，也就是屏幕第1行的起始地址，物理地址是Oxb80a0
    mov          edi,  0xc00b8000                ; 是把目的地址赋给edi寄存器,是屏幕的第0行的起始地址，物理地址是Oxb8000第0行行首
    rep          movsd                           ; 开始循环复制，直至把第 24 行的数据复制完毕。

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  将最后一行填充为空白  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    mov          ebx,  3840                      ; 最后一行首字符的第一个字节偏移= 1920 * 2
    mov          ecx,  80                        ; 一行是80字符(160字节),每次清空1字符(2字节),一行需要移动80次
  .cls:                                          ; cls 是准备清空最后一行
    mov word [gs:ebx], 0x0720                    ; 0x0720是黑底白字的空格键
    add          ebx,  2                         ; 99~101,循环处理屏幕最后一行中的每 个字符
    loop .cls                                    ; 实现循环执行，它也是用ecx 作为循环计数器，每执行一次，ecx 自动减1，直到为0时停止执行。
    mov           bx,  1920                      ; 将光标值重置为1920,最后一行的首字符.

  .set_cursor:
    ; 将光标设为bx值
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  1 先设置高8位  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    mov           dx,  0x03d4                    ; 索引寄存器.是先通过 Ox3d4 端口写入待操作寄存器的索引
    mov           al,  0x0e                      ; 用于提供光标位置的高8位
    out           dx,  al
    mov           dx,  0x03d5                    ; 通过读写数据端口0x3d5来获得或设置光标位置 
    mov           al,  bh
    out           dx,  al

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  2 再设置低8位  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    mov           dx,  0x03d4
    mov           al,  0x0f
    out           dx,  al
    mov           dx,  0x03d5
    mov           al,  bl
    out           dx,  al
  .put_char_done:
    popad
    ret

;--------------------------------------  将小端字节序的数字变成对应的ascii后，倒置   ------------------------------
;输入：栈中参数为待打印的数字
;输出：在屏幕上打印16进制数字,并不会打印前缀0x,如打印10进制15时，只会直接打印f，不会是0xf
;------------------------------------------------------------------------------------------------------------

global put_int
put_int:
    pushad                                       ; 下面四行备份寄存器环境
    mov           ebp,  esp                      
    mov           eax,  [ebp + 4*9]              ; call的返回地址占4字节+pushad的8个4字节
    mov           edx,  eax
    mov           edi,  7                        ; 指定在put_int_buffer中初始的偏移量
    mov           ecx,  8                        ; 32位数字中,16进制数字的位数是8个
    mov           ebx,  put_int_buffer           ; 把ebx作为缓冲区的基址

; 将32位数字按照16进制的形式从低位到高位逐个处理,共处理8个16进制数字
  .16based_4bits:                                ; 每4位二进制是16进制数字的1位,遍历每一位16进制数字
    and           edx,  0x0000_000F              ; 解析16进制数字的每一位。and与操作后,edx只有低4位有效
    cmp           edx,  9                        ; 数字0～9和a~f需要分别处理成对应的字符
    jg  .is_A2F
    add           edx,  '0'                      ; ascii码是8位大小。add求和操作后,edx低8位有效。
    jmp .store                                   
  .is_A2F:
    sub           edx,  10                       ; A~F 减去10 所得到的差,再加上字符A的ascii码,便是A~F对应的ascii码
    add           edx,  'A'                      

; 将每一位数字转换成对应的字符后,按照类似“大端”的顺序存储到缓冲区put_int_buffer
; 高位字符放在低地址,低位字符要放在高地址,这样和大端字节序类似,只不过咱们这里是字符序
  .store:                                        ; 开始存储字符
  ; 此时dl中应该是数字对应的字符的ascii码
    mov     [ebx+edi],  dl                       
    dec           edi
    shr           eax,  4
    mov           edx,  eax
    loop .16based_4bits

; 现在put_int_buffer中已全是字符,打印之前,
; 把高位连续的字符去掉,比如把字符000123变成123
  .ready_to_print:                               ; 准备跳过原来数字中的高位的0
    inc           edi                            ; 此时edi退减为-1(0xffffffff),加1使其为0
  .skip_prefix_0:                                
    cmp           edi,  8                        ; 若已经比较第9个字符了，表示待打印的字符串为全0
    je  .full0                                   
  ; 找出连续的0字符, edi做为非0的最高位字符的偏移
  .go_on_skip:                                ; 缓冲区中的偏移从 起便指向最高位字符
    mov            cl,  [put_int_buffer + edi]   
    inc           edi                            
    cmp            cl,  '0'                      
    je  .skip_prefix_0                           ; 继续判断下一位字符是否为字符0(不是数字0)
    dec           edi                            ; edi在上面的inc操作中指向了下一个字符,若当前字符不为'0',要恢复edi指向当前字符		       
    jmp .put_each_num                            

  .full0:
    mov            cl,  '0'                      ; 输入的数字为全0时，则只打印0
  .put_each_num:
    push          ecx                            ; 此时cl中为可打印的字符
    call put_char
    add           esp,  4
    inc           edi                            ; 使edi指向下一个字符
    mov            cl,  [put_int_buffer + edi]   ; 获取下一个字符到cl寄存器
    cmp           edi,  8
    jl .put_each_num
    popad                                        ; 用popad指令恢复32为寄存器环境后
    ret                                          ; 返回

global set_cursor
set_cursor:

    pushad
    mov            bx,  [esp+36]
;;;;;;;;;;;;;;;;;;;;;;;;;;;;  1 先设置高8位  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    mov            dx,  0x03d4                   ; 索引寄存器
    mov            al,  0x0e                     ; 用于提供光标位置的高8位
    out            dx,  al
    mov            dx,  0x03d5                   ; 通过读写数据端口0x3d5来获得或设置光标位置 
    mov            al,  bh
    out            dx,  al

;;;;;;;;;;;;;;;;;;;;;;;;;;;;  2 再设置低8位  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    mov            dx,  0x03d4
    mov            al,  0x0f
    out            dx,  al
    mov            dx,  0x03d5 
    mov            al,  bl
    out            dx,  al
    popad
    ret

global cls_screen
cls_screen:
    pushad
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	  ; 由于用户程序的cpl为3,显存段的dpl为0,故用于显存段的选择子gs在低于自己特权的环境中为0,
	  ; 导致用户程序再次进入中断后,gs为0,故直接在put_str中每次都为gs赋值. 
    mov            ax,  SELECTOR_VIDEO	         ; 不能直接把立即数送入gs,须由ax中转
    mov            gs,  ax

    mov           ebx,  0
    mov           ecx,  80*25
 .cls:
    mov word [gs:ebx], 0x0720		                 ; 0x0720是黑底白字的空格键
    add           ebx, 2
    loop .cls 
    mov           ebx, 0

 .set_cursor:				                             ; 直接把set_cursor搬过来用,省事
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 1 先设置高8位 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   mov             dx,  0x03d4			             ; 索引寄存器
   mov             al,  0x0e				             ; 用于提供光标位置的高8位
   out             dx,  al
   mov             dx,  0x03d5			             ; 通过读写数据端口0x3d5来获得或设置光标位置 
   mov             al,  bh
   out             dx,  al

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 2 再设置低8位 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   mov             dx,  0x03d4
   mov             al,  0x0f
   out             dx,  al
   mov             dx,  0x03d5 
   mov             al,  bl
   out             dx,  al
   popad
   ret